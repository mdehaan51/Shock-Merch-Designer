{"ast":null,"code":"/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction getFontId(fontFamily) {\n  return fontFamily.replace(/\\s+/g, \"-\").toLowerCase();\n}\n\nfunction validatePickerId(pickerId) {\n  if (pickerId.match(/[^0-9a-z]/i)) {\n    throw Error(\"The `pickerId` parameter may only contain letters and digits\");\n  }\n}\n\nfunction get(url) {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.overrideMimeType(\"application/json\");\n    request.open(\"GET\", url, true);\n\n    request.onreadystatechange = () => {\n      if (request.readyState === 4) {\n        if (request.status !== 200) {\n          reject(new Error(\"Response has status code \".concat(request.status)));\n        } else {\n          resolve(request.responseText);\n        }\n      }\n    };\n\n    request.send();\n  });\n}\n\nconst LIST_BASE_URL = \"https://www.googleapis.com/webfonts/v1/webfonts\";\n\nfunction getFontList(apiKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const url = new URL(LIST_BASE_URL);\n    url.searchParams.append(\"sort\", \"popularity\");\n    url.searchParams.append(\"key\", apiKey);\n    const response = yield get(url.href);\n    const json = JSON.parse(response);\n    const fontsOriginal = json.items;\n    return fontsOriginal.map(fontOriginal => {\n      const family = fontOriginal.family,\n            subsets = fontOriginal.subsets,\n            others = __rest(fontOriginal, [\"family\", \"subsets\"]);\n\n      return Object.assign(Object.assign({}, others), {\n        family,\n        id: getFontId(family),\n        scripts: subsets\n      });\n    });\n  });\n}\n\nconst previewFontsStylesheet = document.createElement(\"style\");\ndocument.head.appendChild(previewFontsStylesheet);\n\nfunction applyFontPreview(previewFont, selectorSuffix) {\n  const fontId = getFontId(previewFont.family);\n  const style = \"\\n\\t\\t\\t#font-button-\".concat(fontId).concat(selectorSuffix, \" {\\n\\t\\t\\t\\tfont-family: \\\"\").concat(previewFont.family, \"\\\";\\n\\t\\t\\t}\\n\\t\\t\");\n  previewFontsStylesheet.appendChild(document.createTextNode(style));\n}\n\nfunction getActiveFontStylesheet(selectorSuffix) {\n  const stylesheetId = \"active-font-\".concat(selectorSuffix);\n  let activeFontStylesheet = document.getElementById(stylesheetId);\n\n  if (!activeFontStylesheet) {\n    activeFontStylesheet = document.createElement(\"style\");\n    activeFontStylesheet.id = stylesheetId;\n    document.head.appendChild(activeFontStylesheet);\n  }\n\n  return activeFontStylesheet;\n}\n\nfunction applyActiveFont(activeFont, previousFontFamily, selectorSuffix) {\n  const style = \"\\n\\t\\t.apply-font\".concat(selectorSuffix, \" {\\n\\t\\t\\tfont-family: \\\"\").concat(activeFont.family, \"\\\"\").concat(previousFontFamily ? \", \\\"\".concat(previousFontFamily, \"\\\"\") : \"\", \";\\n\\t\\t}\\n\\t\");\n  const activeFontStylesheet = getActiveFontStylesheet(selectorSuffix);\n  activeFontStylesheet.innerHTML = style;\n}\n\nconst PREVIEW_ATTRIBUTE_NAME = \"data-is-preview\";\n\nfunction getStylesheetId(fontId) {\n  return \"font-\".concat(fontId);\n}\n\nfunction stylesheetExists(fontId, isPreview) {\n  const stylesheetNode = document.getElementById(getStylesheetId(fontId));\n\n  if (isPreview === null || isPreview === undefined) {\n    return stylesheetNode !== null;\n  }\n\n  return stylesheetNode !== null && stylesheetNode.getAttribute(PREVIEW_ATTRIBUTE_NAME) === isPreview.toString();\n}\n\nfunction createStylesheet(fontId, isPreview) {\n  const stylesheetNode = document.createElement(\"style\");\n  stylesheetNode.id = getStylesheetId(fontId);\n  stylesheetNode.setAttribute(PREVIEW_ATTRIBUTE_NAME, isPreview.toString());\n  document.head.appendChild(stylesheetNode);\n}\n\nfunction fillStylesheet(fontId, styles) {\n  const stylesheetId = getStylesheetId(fontId);\n  const stylesheetNode = document.getElementById(stylesheetId);\n\n  if (stylesheetNode) {\n    stylesheetNode.textContent = styles;\n  } else {\n    console.error(\"Could not fill stylesheet: Stylesheet with ID \\\"\".concat(stylesheetId, \"\\\" not found\"));\n  }\n}\n\nfunction setStylesheetType(fontId, isPreview) {\n  const stylesheetId = getStylesheetId(fontId);\n  const stylesheetNode = document.getElementById(stylesheetId);\n\n  if (stylesheetNode) {\n    stylesheetNode.setAttribute(PREVIEW_ATTRIBUTE_NAME, isPreview.toString());\n  } else {\n    console.error(\"Could not change stylesheet type: Stylesheet with ID \\\"\".concat(stylesheetId, \"\\\" not found\"));\n  }\n}\n\nfunction getMatches(regex, str) {\n  const matches = [];\n  let match;\n\n  do {\n    match = regex.exec(str);\n\n    if (match) {\n      matches.push(match[1]);\n    }\n  } while (match);\n\n  return matches;\n}\n\nconst FONT_FACE_REGEX = /@font-face {([\\s\\S]*?)}/gm;\nconst FONT_FAMILY_REGEX = /font-family: ['\"](.*?)['\"]/gm;\n\nfunction extractFontStyles(allFontStyles) {\n  const rules = getMatches(FONT_FACE_REGEX, allFontStyles);\n  const fontStyles = {};\n  rules.forEach(rule => {\n    const fontFamily = getMatches(FONT_FAMILY_REGEX, rule)[0];\n    const fontId = getFontId(fontFamily);\n\n    if (!(fontId in fontStyles)) {\n      fontStyles[fontId] = \"\";\n    }\n\n    fontStyles[fontId] += \"@font-face {\\n\".concat(rule, \"\\n}\\n\\n\");\n  });\n  return fontStyles;\n}\n\nconst FONT_BASE_URL = \"https://fonts.googleapis.com/css\";\n\nfunction getStylesheet(fonts, scripts, variants, previewsOnly) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const url = new URL(FONT_BASE_URL);\n    const variantsStr = variants.join(\",\");\n    const familiesStr = fonts.map(font => \"\".concat(font.family, \":\").concat(variantsStr));\n    url.searchParams.append(\"family\", familiesStr.join(\"|\"));\n    url.searchParams.append(\"subset\", scripts.join(\",\"));\n\n    if (previewsOnly) {\n      const familyNamesConcat = fonts.map(font => font.family).join(\"\");\n      const downloadChars = familyNamesConcat.split(\"\").filter((char, pos, self) => self.indexOf(char) === pos).join(\"\");\n      url.searchParams.append(\"text\", downloadChars);\n    }\n\n    url.searchParams.append(\"font-display\", \"swap\");\n    return get(url.href);\n  });\n}\n\nfunction loadFontPreviews(fonts, scripts, variants, selectorSuffix) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const fontsArray = Array.from(fonts.values());\n    const fontsToFetch = fontsArray.map(font => font.id).filter(fontId => !stylesheetExists(fontId));\n    fontsToFetch.forEach(fontId => createStylesheet(fontId, true));\n    const response = yield getStylesheet(fontsArray, scripts, variants, true);\n    const fontStyles = extractFontStyles(response);\n    fontsArray.forEach(font => {\n      applyFontPreview(font, selectorSuffix);\n\n      if (fontsToFetch.includes(font.id)) {\n        if (!(font.id in fontStyles)) {\n          console.error(\"Missing styles for font \\\"\".concat(font.family, \"\\\" (fontId \\\"\").concat(font.id, \"\\\") in Google Fonts response\"));\n          return;\n        }\n\n        fillStylesheet(font.id, fontStyles[font.id]);\n      }\n    });\n  });\n}\n\nfunction loadActiveFont(font, previousFontFamily, scripts, variants, selectorSuffix) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (stylesheetExists(font.id, false)) {\n      applyActiveFont(font, previousFontFamily, selectorSuffix);\n    } else {\n      if (stylesheetExists(font.id, true)) {\n        setStylesheetType(font.id, false);\n      } else {\n        createStylesheet(font.id, false);\n      }\n\n      const fontStyle = yield getStylesheet([font], scripts, variants, false);\n      applyActiveFont(font, previousFontFamily, selectorSuffix);\n      fillStylesheet(font.id, fontStyle);\n    }\n  });\n}\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \"@charset \\\"UTF-8\\\";\\ndiv[id^=font-picker] {\\n  position: relative;\\n  display: inline-block;\\n  width: 200px;\\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);\\n}\\ndiv[id^=font-picker] * {\\n  box-sizing: border-box;\\n}\\ndiv[id^=font-picker] p {\\n  margin: 0;\\n  padding: 0;\\n}\\ndiv[id^=font-picker] button {\\n  color: inherit;\\n  font-size: inherit;\\n  background: none;\\n  border: 0;\\n  outline: none;\\n  cursor: pointer;\\n}\\ndiv[id^=font-picker] .dropdown-button {\\n  display: flex;\\n  align-items: center;\\n  justify-content: space-between;\\n  width: 100%;\\n  height: 35px;\\n  padding: 0 10px;\\n  background: #cbcbcb;\\n}\\ndiv[id^=font-picker] .dropdown-button:hover, div[id^=font-picker] .dropdown-button:focus {\\n  background: #bebebe;\\n}\\ndiv[id^=font-picker] .dropdown-button .dropdown-font-name {\\n  overflow: hidden;\\n  white-space: nowrap;\\n}\\ndiv[id^=font-picker] .dropdown-icon {\\n  margin-left: 10px;\\n}\\n@-webkit-keyframes spinner {\\n  to {\\n    transform: rotate(360deg);\\n  }\\n}\\n@keyframes spinner {\\n  to {\\n    transform: rotate(360deg);\\n  }\\n}\\ndiv[id^=font-picker] .dropdown-icon.loading::before {\\n  display: block;\\n  width: 10px;\\n  height: 10px;\\n  border: 2px solid #b2b2b2;\\n  border-top-color: #000000;\\n  border-radius: 50%;\\n  -webkit-animation: spinner 0.6s linear infinite;\\n          animation: spinner 0.6s linear infinite;\\n  content: \\\"\\\";\\n}\\ndiv[id^=font-picker] .dropdown-icon.finished::before {\\n  display: block;\\n  width: 0;\\n  height: 0;\\n  margin: 0 2px;\\n  border-top: 6px solid #000000;\\n  border-right: 5px solid transparent;\\n  border-left: 5px solid transparent;\\n  transition: transform 0.3s;\\n  content: \\\"\\\";\\n}\\ndiv[id^=font-picker] .dropdown-icon.error::before {\\n  content: \\\"⚠\\\";\\n}\\ndiv[id^=font-picker].expanded .dropdown-icon.finished::before {\\n  transform: rotate(-180deg);\\n}\\ndiv[id^=font-picker].expanded ul {\\n  max-height: 200px;\\n}\\ndiv[id^=font-picker] ul {\\n  position: absolute;\\n  z-index: 1;\\n  width: 100%;\\n  max-height: 0;\\n  margin: 0;\\n  padding: 0;\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  background: #eaeaea;\\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);\\n  transition: 0.3s;\\n  -webkit-overflow-scrolling: touch;\\n}\\ndiv[id^=font-picker] ul li {\\n  height: 35px;\\n  list-style: none;\\n}\\ndiv[id^=font-picker] ul li button {\\n  display: flex;\\n  align-items: center;\\n  width: 100%;\\n  height: 100%;\\n  padding: 0 10px;\\n  white-space: nowrap;\\n}\\ndiv[id^=font-picker] ul li button:hover, div[id^=font-picker] ul li button:focus {\\n  background: #dddddd;\\n}\\ndiv[id^=font-picker] ul li button.active-font {\\n  background: #d1d1d1;\\n}\";\nstyleInject(css);\nconst FONT_FAMILY_DEFAULT = \"Open Sans\";\nconst OPTIONS_DEFAULTS = {\n  pickerId: \"\",\n  families: [],\n  categories: [],\n  scripts: [\"latin\"],\n  variants: [\"regular\"],\n  limit: 50,\n  sort: \"alphabet\"\n};\n\nclass FontManager {\n  constructor(apiKey, defaultFamily = FONT_FAMILY_DEFAULT, {\n    pickerId = OPTIONS_DEFAULTS.pickerId,\n    families = OPTIONS_DEFAULTS.families,\n    categories = OPTIONS_DEFAULTS.categories,\n    scripts = OPTIONS_DEFAULTS.scripts,\n    variants = OPTIONS_DEFAULTS.variants,\n    limit = OPTIONS_DEFAULTS.limit,\n    sort = OPTIONS_DEFAULTS.sort\n  }, onChange = () => {}) {\n    this.fonts = new Map();\n    validatePickerId(pickerId);\n    this.selectorSuffix = pickerId ? \"-\".concat(pickerId) : \"\";\n    this.apiKey = apiKey;\n    this.options = {\n      pickerId,\n      families,\n      categories,\n      scripts,\n      variants,\n      limit,\n      sort\n    };\n    this.onChange = onChange;\n    this.addFont(defaultFamily, false);\n    this.setActiveFont(defaultFamily, false);\n  }\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const fonts = yield getFontList(this.apiKey);\n\n      for (let i = 0; i < fonts.length; i += 1) {\n        const font = fonts[i];\n\n        if (this.fonts.size >= this.options.limit) {\n          break;\n        }\n\n        if (!this.fonts.has(font.family) && (this.options.families.length === 0 || this.options.families.includes(font.family)) && (this.options.categories.length === 0 || this.options.categories.includes(font.category)) && this.options.scripts.every(script => font.scripts.includes(script)) && this.options.variants.every(variant => font.variants.includes(variant))) {\n          this.fonts.set(font.family, font);\n        }\n      }\n\n      const fontsToLoad = new Map(this.fonts);\n      fontsToLoad.delete(this.activeFontFamily);\n      loadFontPreviews(fontsToLoad, this.options.scripts, this.options.variants, this.selectorSuffix);\n      return this.fonts;\n    });\n  }\n\n  getFonts() {\n    return this.fonts;\n  }\n\n  addFont(fontFamily, downloadPreview = true) {\n    const font = {\n      family: fontFamily,\n      id: getFontId(fontFamily)\n    };\n    this.fonts.set(fontFamily, font);\n\n    if (downloadPreview) {\n      const fontMap = new Map();\n      fontMap.set(fontFamily, font);\n      loadFontPreviews(fontMap, this.options.scripts, this.options.variants, this.selectorSuffix);\n    }\n  }\n\n  removeFont(fontFamily) {\n    this.fonts.delete(fontFamily);\n  }\n\n  getActiveFont() {\n    const activeFont = this.fonts.get(this.activeFontFamily);\n\n    if (!activeFont) {\n      throw Error(\"Cannot get active font: \\\"\".concat(this.activeFontFamily, \"\\\" is not in the font list\"));\n    } else {\n      return activeFont;\n    }\n  }\n\n  setActiveFont(fontFamily, runOnChange = true) {\n    const previousFontFamily = this.activeFontFamily;\n    const activeFont = this.fonts.get(fontFamily);\n\n    if (!activeFont) {\n      throw Error(\"Cannot update active font: \\\"\".concat(fontFamily, \"\\\" is not in the font list\"));\n    }\n\n    this.activeFontFamily = fontFamily;\n    loadActiveFont(activeFont, previousFontFamily, this.options.scripts, this.options.variants, this.selectorSuffix).then(() => {\n      if (runOnChange) {\n        this.onChange(activeFont);\n      }\n    });\n  }\n\n  setOnChange(onChange) {\n    this.onChange = onChange;\n  }\n\n}\n\nexport { FONT_FAMILY_DEFAULT, FontManager, OPTIONS_DEFAULTS, getFontId };","map":null,"metadata":{},"sourceType":"module"}